import numpy as np
import time
import math
import file_utils
import plot_utils
import common_utils
import signal_utils
import kernel_manager
import configuration


def calculate_spike_times(all_convolutions, ahp_period=configuration.ahp_period,
                          threshold=configuration.spiking_threshold):
    """
    Computes the spikes for all kernels
    """
    if configuration.verbose:
        start_time = time.process_time()
    spike_indexes = []
    spike_times = []
    threshold_values = []
    for i in range(len(all_convolutions)):
        this_kernel_spikes, ths = calculate_spikes_for_one_kernel(all_convolutions, i, ahp_period, threshold)
        spike_times = np.concatenate([spike_times, this_kernel_spikes])
        print(f'number of generated spikes: {len(this_kernel_spikes)}')
        spike_indexes = np.concatenate([spike_indexes, int(i) * np.ones(len(this_kernel_spikes))]).astype(int)
        threshold_values = np.concatenate([threshold_values, ths])
        print(spike_indexes)
    # threshold_values = calculate_threshold_crossing_values(spike_times, spike_indexes)
    if configuration.verbose:
        print(
            f'number of spikes: {len(spike_times)} and time to compute the spike: {time.process_time() - start_time}s')
    return spike_times, spike_indexes, threshold_values


def calculate_spikes_for_one_kernel(all_convolutions, kernel_index, ahp_period=configuration.ahp_period,
                                    threshold=configuration.spiking_threshold):
    """
    This method computes spikes generated by a given kernel
    :param all_convolutions:
    :param ahp_period:
    :param threshold:
    :param kernel_index:
    :return:
    """
    last_spike_time = -1
    this_kernel_spike_times = []
    threshold_values = []
    this_convolution = all_convolutions[kernel_index]
    for i in range(len(this_convolution)):
        if last_spike_time == -1 or (i - last_spike_time) > ahp_period:
            ahp_effect_now = 0
        else:
            ahp_effect_now = configuration.ahp_high_value * ((i - last_spike_time) / ahp_period)
        threshold_now = threshold + ahp_effect_now
        if threshold_now <= this_convolution[i]:
            last_spike_time = i
            this_kernel_spike_times.append(i)
            threshold_values.append(this_convolution[i])
    return this_kernel_spike_times, threshold_values


# def get_sq(x):
#     return x * x
#
#
# def gen_sq():
#     i = 0
#     while i < x:
#         yield i * i
#         i = i+1


# import time
# x = 100000
# st = time.process_time()
# np.fromiter((get_sq(x) for x in range(x)), int)
# print(f'time for execution: {time.process_time() - st}')
#
# st = time.process_time()
# np.fromiter([x * x for x in range(x)], int)
# print(f'time for execution: {time.process_time() - st}')
#
#
# # ar = np.zeros(x)
# st = time.process_time()
# ar = np.fromiter(gen_sq(), dtype=int)
# print(f'time for execution: {time.process_time() - st}')
#
# st = time.process_time()
# ar = np.array([x * x for x in range(x)], int)
# print(f'time for execution: {time.process_time() - st}')
# def calculate_threshold_crossing_values(spike_times, spike_indexes, thresholds=None):
#     """
#     This method populates the np array of the thresholds at which spikes were produced
#     :param spike_indexes:
#     :param spike_times:
#     :param thresholds:
#     """
#     if thresholds is None:
#         threshold_crossing_values = np.zeros(len(spike_times))
#         for i in range(len(spike_times)):
#             threshold_crossing_values[i] = all_convolutions[spike_indexes[i]][int(spike_times[i])]
#     else:
#         threshold_crossing_values = np.array(thresholds)
#     return threshold_crossing_values
