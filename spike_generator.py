import numpy as np
import time
import math
import file_utils
import plot_utils
import common_utils
import signal_utils
import kernel_manager
import configuration

delta_thres = 0
abs_thres = 0


def calculate_spike_times(all_convolutions, ahp_period=configuration.ahp_period, ahp_high=configuration.ahp_high_value,
                          threshold=configuration.spiking_threshold,
                          selected_kernel_indexes=None, offset=0, start_time=0, end_time=-1, each_kernel_spikes=None):
    """
    Computes the spikes for all kernels
    :param end_time:
    :param all_convolutions:
    :param ahp_period:
    :param ahp_high:
    :param threshold:
    :param selected_kernel_indexes:
    :param offset:
    :param start_time:
    :param each_kernel_spikes:
    :return:
    """
    global abs_thres, delta_thres
    delta_thres = 0
    abs_thres = 0
    if configuration.verbose:
        start_time = time.process_time()
    # spike_indexes = []
    # spike_times = []
    # threshold_values = []
    if configuration.verbose:
        spike_counts = np.zeros(len(all_convolutions))
    else:
        spike_counts = None
    # TODO: depreciated scheme of calculating spikes individually for each kernel
    # for i in range(len(all_convolutions)):
    #     if selected_kernel_indexes is not None and i not in selected_kernel_indexes:
    #         continue
    #     this_kernel_spikes, ths = calculate_spikes_for_one_kernel(all_convolutions, i, ahp_period, ahp_high, threshold)
    #     spike_times = np.concatenate([spike_times, this_kernel_spikes])
    #     spike_indexes = np.concatenate([spike_indexes, int(i) * np.ones(len(this_kernel_spikes))]).astype(int)
    #     if configuration.verbose:
    #         spike_counts[i] = len(this_kernel_spikes)
    #     threshold_values = np.concatenate([threshold_values, ths])
    spike_times, spike_indexes, threshold_values = \
        calculate_spikes_for_all_kernels(all_convolutions, selected_kernel_indexes, ahp_period,
                                         ahp_high, threshold, spike_counts,
                                         offset=offset,
                                         start_time=start_time,
                                         end_time=end_time,
                                         each_kernel_spikes=each_kernel_spikes)
    if len(spike_times) == 0:
        return [], [], []
    if configuration.debug:
        print(f'check the spike counts here: {len(spike_times)}')
        print(f' the percentage error is transmitting threshold: {100 * delta_thres / abs_thres}')
    if configuration.verbose:
        print(f'check the spike counts here: {spike_counts}')
        print(
            f'number of spikes: {len(spike_times)} and time to compute the spike: {time.process_time() - start_time}s')
    return spike_times, spike_indexes, threshold_values


def calculate_spikes_for_one_kernel(all_convolutions, kernel_index, ahp_period=configuration.ahp_period,
                                    ahp_high=configuration.ahp_high_value,
                                    threshold=configuration.spiking_threshold):
    """
    This method computes spikes generated by a given kernel
    :param ahp_high:
    :param all_convolutions:
    :param ahp_period:
    :param threshold:
    :param kernel_index:
    :return:
    """
    last_spike_time = -1
    this_kernel_spike_times = []
    threshold_values = []
    this_convolution = all_convolutions[kernel_index]
    last_spikes = []
    global abs_thres, delta_thres
    for i in range(len(this_convolution)):
        ahp_effect_now = 0
        if last_spike_time > -1:
            for n in range(len(last_spikes) - 1, -1, -1):
                time_diff = i - last_spikes[n]
                if time_diff > ahp_period:
                    break
                else:
                    ahp_effect_now = ahp_effect_now + \
                                     ahp_high * ((ahp_period - time_diff) / ahp_period)
        threshold_now = threshold + ahp_effect_now
        if threshold_now <= this_convolution[i]:
            # print(f' threshold: {threshold_now} and convolution: {this_convolution[i]} and convolution prior:'
            #       f'{-1 if i <= 0 else this_convolution[i - 1]} at time {i} with last spike {last_spike_time}')
            last_spike_time = i
            last_spikes.append(i)
            this_kernel_spike_times.append(i)
            if configuration.quantized_threshold_transmission:
                threshold_values.append(threshold_now)
            else:
                threshold_values.append(this_convolution[i])
            if configuration.debug:
                abs_thres = abs_thres + abs(this_convolution[i])
                delta_thres = delta_thres + abs(threshold_now - this_convolution[i])
                print(f'percentage error for this threshold: '
                      f'{100 * abs(threshold_now - this_convolution[i]) / abs(this_convolution[i])} '
                      f' index: {kernel_index} and time: {i}\n'
                      f' and the total percentage is: {100 * delta_thres / abs_thres}')
            # print(f' threshold: {threshold_now} and convolution: {this_convolution[i]} and convolution prior:'
            #       f'{-1 if i <= 0 else this_convolution[i - 1]}')
    return this_kernel_spike_times, threshold_values


def calculate_spikes_for_all_kernels(all_convolutions, selected_kernel_indexes, ahp_period=configuration.ahp_period,
                                     ahp_high=configuration.ahp_high_value, threshold=configuration.spiking_threshold,
                                     spike_counts=None, offset=0, start_time=0, end_time=-1, each_kernel_spikes=None):
    """
    This method computes spikes generated by all kernels
    :param end_time:
    :param start_time:
    :param each_kernel_spikes:
    :param offset:
    :param ahp_high:
    :param spike_counts: counts of individual kernel spikes
    :param selected_kernel_indexes:
    :param all_convolutions:
    :param ahp_period:
    :param threshold:
    :return:
    """
    all_spike_times = []
    threshold_values = []
    spike_indexes = []
    if each_kernel_spikes is None:
        spikes_of_each_kernel = [[] for i in range(len(all_convolutions))]
    else:
        spikes_of_each_kernel = each_kernel_spikes
    global abs_thres, delta_thres
    for i in range(start_time - offset, len(all_convolutions[0]) if end_time == -1 else end_time - offset):
        for index in range(len(all_convolutions)):
            if selected_kernel_indexes is not None and index not in selected_kernel_indexes:
                continue
            if i >= len(all_convolutions[index]):
                continue
            this_convolution = all_convolutions[index]
            last_spikes = spikes_of_each_kernel[index]
            ahp_effect_now = 0
            for n in range(len(last_spikes) - 1, -1, -1):
                time_diff = (i+offset) - last_spikes[n]
                if time_diff > ahp_period:
                    break
                else:
                    ahp_effect_now = ahp_effect_now + \
                                     ahp_high * ((ahp_period - time_diff) / ahp_period)

            threshold_now = threshold + ahp_effect_now
            if threshold_now <= this_convolution[i]:
                if configuration.debug:
                    print(f' threshold: {threshold_now} and convolution: {this_convolution[i]} and convolution prior:'
                          f'{-1 if i <= 0 else this_convolution[i - 1]} at time {i} with last spike '
                          f'{-1 if len(spikes_of_each_kernel[index]) == 0 else spikes_of_each_kernel[index][-1]}')
                spikes_of_each_kernel[index].append(i + offset)
                all_spike_times.append(i + offset)
                spike_indexes.append(index)
                if spike_counts is not None:
                    spike_counts[index] = spike_counts[index] + 1
                if configuration.quantized_threshold_transmission:
                    threshold_values.append(threshold_now)
                else:
                    threshold_values.append(this_convolution[i])
                if configuration.debug:
                    abs_thres = abs_thres + abs(this_convolution[i])
                    delta_thres = delta_thres + abs(this_convolution[i] - threshold_now)
    return all_spike_times, spike_indexes, threshold_values
