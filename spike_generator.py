import numpy as np
import time
import math
import file_utils
import plot_utils
import common_utils
import signal_utils
import kernel_manager
import configuration


def calculate_spike_times(all_convolutions, ahp_period=configuration.ahp_period,
                          threshold=configuration.spiking_threshold):
    """
    Computes the spikes for all kernels
    """
    if configuration.verbose:
        start_time = time.process_time()
    spike_indexes = []
    spike_times = []
    threshold_values = []
    for i in range(len(all_convolutions)):
        this_kernel_spikes, ths = calculate_spikes_for_one_kernel(all_convolutions, i, ahp_period, threshold)
        spike_times = np.concatenate([spike_times, this_kernel_spikes])
        spike_indexes = np.concatenate([spike_indexes, int(i) * np.ones(len(this_kernel_spikes))]).astype(int)
        threshold_values = np.concatenate([threshold_values, ths])
    if configuration.verbose:
        print(
            f'number of spikes: {len(spike_times)} and time to compute the spike: {time.process_time() - start_time}s')
    return spike_times, spike_indexes, threshold_values


def calculate_spikes_for_one_kernel(all_convolutions, kernel_index, ahp_period=configuration.ahp_period,
                                    threshold=configuration.spiking_threshold):
    """
    This method computes spikes generated by a given kernel
    :param all_convolutions:
    :param ahp_period:
    :param threshold:
    :param kernel_index:
    :return:
    """
    last_spike_time = -1
    this_kernel_spike_times = []
    threshold_values = []
    this_convolution = all_convolutions[kernel_index]
    for i in range(len(this_convolution)):
        if last_spike_time == -1 or (i - last_spike_time) > ahp_period:
            ahp_effect_now = 0
        else:
            ahp_effect_now = configuration.ahp_high_value * ((i - last_spike_time) / ahp_period)
        threshold_now = threshold + ahp_effect_now
        if threshold_now <= this_convolution[i]:
            last_spike_time = i
            this_kernel_spike_times.append(i)
            threshold_values.append(this_convolution[i])
    return this_kernel_spike_times, threshold_values
